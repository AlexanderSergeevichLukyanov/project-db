О PairingHeap и SoftHeap
Существует 3 уровня уровня куч:
1 -- обычная куча с компаратором в RAM
2 -- куча в RAM на минимальных элементах блока
3 -- верхняя оболочка, добавляющая операции DecreaseKey, delete

1. Куча в RAM обладает стандартными операциями insert, extract, top. Все, работают быстро -- O(1), кроме extract у pairing -- O(log n), и insert у soft медленнее.

2. Разобьём все данные на блоки размера B и выберем внутри каждого блока минимальный элемент. Назовём его головой, а остальную часть хвостом. На этих минимальных элементах построим кучу, а хвосты запишем на диск. При insert добавляем всё в буфер, как только он близок к размеру B -- флашим. При extracte считываем весь блок в оперативку и формируем новый с новым минимумом. 

Это было для понимания, теперь оптимизируем: будем в голове хранить несколько первых минимальных элементов: (всегда может быть от 1 до k). При extract просто уменьшится количество элементов в голове => работы с диском нет. Также при возможности можно пополнить голову из буфера (если минимум буфера меньше максимума головы). Если же голова всё же опустошилась, считываем блок в буфер, при переполнении флашим.

Еще оптимизируем: при extractе минимум может лежать в буфере или в куче. Будем поддерживать инвариант размера буфера от B до 3B. Если становится больше 2B, то делаем флаш. При этом стремимся сфлашить максимальные B элементов, чтобы минимумы оставались в буфере. 

Структура для буфера -- MinMaxHeap. Почти за чистый логарифм на массиве, без всяких выделений памяти можно извлекать максимум, минимум, делать вставку.

Как подобрать k в голове? Если указан максимальный объём данных -- рассчитываем из оперативки. По умолчанию -- 3. (1 как-то бессмысленно, ибо при каждой операции читаем, 2 -- маловато).

3. Ну а тут стандартная идея с алгоритмов (Build -> Delete) -- поддерживаем кучу удаленных. 